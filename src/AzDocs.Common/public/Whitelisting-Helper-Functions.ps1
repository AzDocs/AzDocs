#region Helper functions

<#
.SYNOPSIS
    Add Access restriction to app service and/or function app
.DESCRIPTION
    Add Access restriction to app service and/or function app
#>
# We need to check based on the following: 
# AccessRestrictionRuleName is always filled. Based upon AutoGeneratedAccessRestrictionRuleName we verify if we have to check on this. 
# OR CIDRToWhiteList is filled
# OR SubnetResourceId is filled 

# We want to check if the access restriction already exists, so that we don't send a delete for something that doesn't exist. 
function Add-AccessRestriction
{
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)][string] [ValidateSet('functionapp', 'webapp')]$AppType,
        [Parameter(Mandatory)][string] $ResourceGroupName,
        [Parameter(Mandatory)][string] $ResourceName,
        [Parameter()][string] $AccessRestrictionRuleDescription,
        [Parameter()][string] $DeploymentSlotName,
        [Parameter()][string] $AccessRestrictionAction = "Allow",
        [Parameter()][string] $Priority = 10,
        [Parameter()][string] $AccessRestrictionRuleName,
        [Parameter(Mandatory)][bool] $AutoGeneratedAccessRestrictionRuleName,
        [Parameter()][ValidatePattern('^$|^(?:(?:\d{1,3}.){3}\d{1,3})(?:\/(?:\d{1,2}))?$', ErrorMessage = "The text '{0}' does not match with the CIDR notation, like '1.2.3.4/32'")][string] $CIDR,
        [Parameter()][string] $SubnetResourceId,
        [Parameter()][bool] $ApplyToMainEntrypoint = $true,
        [Parameter()][bool] $ApplyToScmEntrypoint = $true
    )

    Write-Header -ScopedPSCmdlet $PSCmdlet

    # If CIDRToWhitelist is empty AND SubnetResourceId is empty, something went wrong.
    Confirm-CIDRorSubnetResourceIdOrAccessRuleNameNotEmpty -CIDR $CIDR -SubnetResourceId $SubnetResourceId -AccessRestrictionRuleName $AccessRestrictionRuleName
    
    # fill parameters
    $optionalParameters = @()
    if ($CIDR)
    {
        $optionalParameters += "--ip-address", "$CIDR"
    }
    elseif ($SubnetResourceId)
    {
        $optionalParameters += "--subnet", "$SubnetResourceId"
    }
   
    if ($DeploymentSlotName)
    {
        $optionalParameters += "--slot", "$DeploymentSlotName"
    }
    
    if ($AccessRestrictionRuleDescription)
    {
        $optionalParameters += "--description", "$AccessRestrictionRuleDescription"
    }

    Write-Host @removeIfExistsRestrictionParameters 

    # Check and remove access restriction if it already exists
    Remove-AccessRestrictionIfExists -AppType $AppType -ResourceGroupName $ResourceGroupName -ResourceName $ResourceName -ApplyToMainEntryPoint $ApplyToMainEntryPoint -ApplyToScmEntryPoint $ApplyToScmEntryPoint -CIDR:$CIDR -SubnetResourceId:$subnetResourceId -DeploymentSlotName:$DeploymentSlotName -AccessRestrictionRuleName:$AccessRestrictionRuleName -AutoGeneratedAccessRestrictionRuleName:$AutoGeneratedAccessRestrictionRuleName
    
    # SCM entrypoint
    if ($ApplyToScmEntrypoint)
    {
        Invoke-Executable az $AppType config access-restriction add --resource-group $ResourceGroupName --name $ResourceName --action $AccessRestrictionAction --priority $Priority --rule-name $AccessRestrictionRuleName --scm-site $true @optionalParameters
    }

    # Main entrypoint
    if ($ApplyToMainEntrypoint)
    {
        Invoke-Executable az $AppType config access-restriction add --resource-group $ResourceGroupName --name $ResourceName --action $AccessRestrictionAction --priority $Priority --rule-name $AccessRestrictionRuleName --scm-site $false @optionalParameters
    }

    Write-Footer -ScopedPSCmdlet $PSCmdlet
}

function Remove-AccessRestrictionIfExists
{
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)][string] [ValidateSet('functionapp', 'webapp')]$AppType,
        [Parameter(Mandatory)][string] $ResourceGroupName,
        [Parameter(Mandatory)][string] $ResourceName,
        [Parameter()][string] $AccessRestrictionRuleName,
        [Parameter(Mandatory)][bool] $AutoGeneratedAccessRestrictionRuleName,
        [Parameter()][string] $CIDR,
        [Parameter()][string] $SubnetResourceId,
        [Parameter()][string] $DeploymentSlotName,
        [Parameter()][bool] $ApplyToMainEntrypoint = $true,
        [Parameter()][bool] $ApplyToScmEntrypoint = $true
    )

    Write-Header -ScopedPSCmdlet $PSCmdlet

    Confirm-CIDRorSubnetResourceIdOrAccessRuleNameNotEmpty -CIDR $CIDR -SubnetResourceId $SubnetResourceId -AccessRestrictionRuleName $AccessRestrictionRuleName

    $optionalParameters = @()
    # Accessrule whenever its not autogenerated
    if (!$AutoGeneratedAccessRestrictionRuleName)
    {
        $optionalParameters += "--rule-name", "$AccessRestrictionRuleName"
    }

    # CIDR / Subnet
    if ($CIDR)
    {
        $optionalParameters += "--ip-address", "$CIDR"
    }
    elseif ($SubnetResourceId)
    {
        $optionalParameters += "--subnet", "$SubnetResourceId"
    }

    # Deploymentslot
    if ($DeploymentSlotName)
    {
        $optionalParameters += "--slot", "$DeploymentSlotName"
    }

    if ($ApplyToScmEntrypoint -and (Confirm-AccessRestriction -AppType $AppType -ResourceGroupName $ResourceGroupName -ResourceName $ResourceName -SecurityRestrictionObjectName "scmIpSecurityRestrictions" -AccessRestrictionRuleName:$AccessRestrictionRuleName -CIDR:$CIDR -SubnetResourceId:$SubnetResourceId -DeploymentSlotName:$DeploymentSlotName -AutoGeneratedAccessRestrictionRuleName:$AutoGeneratedAccessRestrictionRuleName))
    {
        Invoke-Executable az $AppType config access-restriction remove --resource-group $ResourceGroupName --name $ResourceName --scm-site $true @optionalParameters
    }

    # Main entrypoint
    if ($ApplyToMainEntrypoint -and (Confirm-AccessRestriction -AppType $AppType -ResourceGroupName $ResourceGroupName -ResourceName $ResourceName -SecurityRestrictionObjectName "ipSecurityRestrictions" -AccessRestrictionRuleName:$AccessRestrictionRuleName -CIDR:$CIDR -SubnetResourceId:$SubnetResourceId -DeploymentSlotName:$DeploymentSlotName -AutoGeneratedAccessRestrictionRuleName:$AutoGeneratedAccessRestrictionRuleName))
    {
        Invoke-Executable az $AppType config access-restriction remove --resource-group $ResourceGroupName --name $ResourceName --scm-site $false @optionalParameters
    }
}

<#
.SYNOPSIS
    Check if Access restrictions exist on app service and/or function app
.DESCRIPTION
    Check if Access restrictions exist on app service and/or function app
#>

function Confirm-AccessRestriction
{  
    [OutputType([boolean])]
    param (
        [Parameter(Mandatory)][string] [ValidateSet('functionapp', 'webapp')] $AppType,
        [Parameter(Mandatory)][string] $ResourceGroupName,
        [Parameter(Mandatory)][string] $ResourceName,
        [Parameter()][string] $AccessRestrictionRuleName,
        [Parameter(Mandatory)][bool] $AutoGeneratedAccessRestrictionRuleName,
        [Parameter()][string] $CIDR,
        [Parameter()][string] $SubnetResourceId,
        [Parameter(Mandatory)][ValidateSet("ipSecurityRestrictions", "scmIpSecurityRestrictions")][string] $SecurityRestrictionObjectName,
        [Parameter()][string] $DeploymentSlotName,
        [Parameter()][bool] $ApplyToScmEntryPoint = $true,
        [Parameter()][bool] $ApplyToMainEntryPoint = $true
    )

    Write-Header -ScopedPSCmdlet $PSCmdlet

    Confirm-CIDRorSubnetResourceIdOrAccessRuleNameNotEmpty -CIDR $CIDR -SubnetResourceId $SubnetResourceId -AccessRestrictionRuleName $AccessRestrictionRuleName

    $optionalParameters = @()
    if ($DeploymentSlotName)
    {
        $optionalParameters += "--slot", "$DeploymentSlotName"
    }


    $accessRestrictions = Invoke-Executable az $AppType config access-restriction show --resource-group $ResourceGroupName --name $ResourceName @optionalParameters | ConvertFrom-Json
    if ($AutoGeneratedAccessRestrictionRuleName)
    {
        if ($CIDR)
        {
            if ($accessRestrictions.$SecurityRestrictionObjectName.ip_address -contains $CIDR)
            {
                Write-Host "Access restriction for type $SecurityRestrictionObjectName exists for $CIDR, continueing."
                return $true
            }
            else
            {
                Write-Host "Access restriction for type $SecurityRestrictionObjectName does not exist for $CIDR."
                return $false
            }
        }
        elseif ($SubnetResourceId)
        {
            if ($accessRestrictions.$SecurityRestrictionObjectName.vnet_subnet_resource_id -contains $SubnetResourceId)
            {
                Write-Host "Access restriction for type $SecurityRestrictionObjectName exists for $SubnetResourceId, continueing"
                return $true
            }
            else
            {
                Write-Host "Access restriction for type $SecurityRestrictionObjectName does not exist for $SubnetResourceId."
                return $false
            }
        }
    }

    # AccessRestrictionRuleName is known
    if ($CIDR)
    {
        if ($accessRestrictions.$SecurityRestrictionObjectName.Name -contains $AccessRestrictionRuleName -and $accessRestrictions.$SecurityRestrictionObjectName.ip_address -contains $CIDR)
        {
            Write-Host "Access restriction for type $SecurityRestrictionObjectName exists for $AccessRestrictionRuleName and $CIDR, continueing"
            return $true
        }
        else
        {
            Write-Host "Access restriction for type $SecurityRestrictionObjectName does not exist for $AccessRestrictionRuleName and $CIDR."
            return $false
        }
    }
    elseif ($SubnetResourceId)
    {
        if ($accessRestrictions.$SecurityRestrictionObjectName.Name -contains $AccessRestrictionRuleName -and $accessRestrictions.$SecurityRestrictionObjectName.vnet_subnet_resource_id -contains $SubnetResourceId)
        {
            Write-Host "Access restriction for type $SecurityRestrictionObjectName exists for $AccessRestrictionRuleName and $SubnetResourceId, continueing"
            return $true
        }
        else
        {
            Write-Host "Access restriction for type $SecurityRestrictionObjectName does not exist for $AccessRestrictionRuleName and $SubnetResourceId."
            return $false
        }
    }
    else
    {
        if ($accessRestrictions.$SecurityRestrictionObjectName.Name -contains $AccessRestrictionRuleName)
        {
            Write-Host "Access restriction for type $SecurityRestrictionObjectName exists for $AccessRestrictionRuleName, continueing"
            return $true
        }
        else
        {
            Write-Host "Access restriction for type $SecurityRestrictionObjectName does not exist for $AccessRestrictionRuleName."
            return $false
        }
    }

    Write-Footer -ScopedPSCmdlet $PSCmdlet
}
#endregion

#region Whitelist helper functions MySql/PostgreSql/SqlServer 

function Remove-FirewallRulesIfExists
{    
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)][string] [ValidateSet('mysql', 'postgres', 'sql')]$ServiceType,
        [Parameter(Mandatory)][string] $ResourceGroupName,
        [Parameter(Mandatory)][string] $ResourceName,
        [Parameter()][string] $AccessRuleName, 
        [Parameter()][ValidatePattern('^$|^(?:(?:\d{1,3}.){3}\d{1,3})(?:\/(?:\d{1,2}))?$', ErrorMessage = "The text '{0}' does not match with the CIDR notation, like '1.2.3.4/32'")][string] $CIDR
    )

    Write-Header -ScopedPSCmdlet $PSCmdlet

    $parameters = @()
    if ($ServiceType -eq 'sql')
    {
        $parameters += '--server', "$ResourceName"
    }
    else
    {
        $parameters += '--server-name', "$ResourceName"
    }

    $matchedFirewallRules = [Collections.Generic.List[string]]::new()
    $firewallRules = Invoke-Executable az $ServiceType server firewall-rule list --resource-group $ResourceGroupName @parameters | ConvertFrom-Json
    if ($AccessRuleName)
    {
        $matchingFirewallRules = $firewallRules | Where-Object { $_.name -eq $AccessRuleName }
        if ($matchingFirewallRules)
        {
            $matchedFirewallRules.Add($AccessRuleName)
        }
    }
    else
    {
        $startIpAddress = Get-StartIpInIpv4Network -SubnetCidr $CIDR
        $endIpAddress = Get-EndIpInIpv4Network -SubnetCidr $CIDR
        $matchingFirewallRules = $firewallRules | Where-Object { $_.startIpAddress -eq $startIpAddress -and $_.endIpAddress -eq $endIpAddress }
        if ($matchingFirewallRules)
        {
            foreach ($matchingFirewallRule in $matchingFirewallRules)
            {
                $matchedFirewallRules.Add($matchingFirewallRule.name)
            }
        }
    }

    if (!($ServiceType -eq 'sql'))
    {
        $parameters += '--yes'
    }

    # Remove firewall rules
    foreach ($ruleName in $matchedFirewallRules) 
    {
        Write-Host "Removing whitelist for $ruleName."
        Invoke-Executable az $ServiceType server firewall-rule delete --resource-group $ResourceGroupName --name $ruleName @parameters
    }

    Write-Footer -ScopedPSCmdlet $PSCmdlet
}

function Remove-VnetRulesIfExists
{
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)][string] [ValidateSet('mysql', 'postgres', 'sql')]$ServiceType,
        [Parameter(Mandatory)][string] $ResourceGroupName,
        [Parameter(Mandatory)][string] $ResourceName,
        [Parameter()][string] $SubnetResourceId,
        [Parameter()][string] $AccessRuleName 
    )

    Write-Header -ScopedPSCmdlet $PSCmdlet

    $parameters = @()
    if ($ServiceType -eq 'sql')
    {
        $parameters += '--server', "$ResourceName"
    }
    else
    {
        $parameters += '--server-name', "$ResourceName"
    }

    $matchedVnetRules = [Collections.Generic.List[string]]::new()
    $vnetRules = Invoke-Executable az $ServiceType server vnet-rule list --resource-group $ResourceGroupName @parameters | ConvertFrom-Json
    if ($AccessRuleName)
    {
        $matchingVnetRules = $vnetRules | Where-Object { $_.name -eq $AccessRuleName }
        if ($matchingVnetRules)
        {
            $matchedVnetRules.Add($AccessRuleName)
        }
    }
    else
    {
        $matchingVnetRules = $vnetRules | Where-Object { $_.virtualNetworkSubnetId -eq $SubnetResourceId }
        if ($matchingVnetRules)
        {
            foreach ($matchingVnetRule in $matchingVnetRules)
            {
                $matchedVnetRules.Add($matchingVnetRule.name)
            }
        }
    }

    # Remove vnet rules
    foreach ($ruleName in $matchedVnetRules) 
    {
        Write-Host "Removing whitelist for $ruleName."
        Invoke-Executable az mysql server vnet-rule delete --resource-group $ResourceGroupName @parameters --name $ruleName
    }

    Write-Footer -ScopedPSCmdlet $PSCmdlet
}
#endregion

#region Validation helper functions

function Confirm-CIDRorSubnetResourceIdOrAccessRuleNameNotEmpty
{
    param (
        [Parameter()][string] $CIDR,
        [Parameter()][string] $SubnetResourceId,
        [Parameter()][string] $AccessRestrictionRuleName
    )

    if (!$CIDR -and !$SubnetResourceId -and !$AccessRestrictionRuleName)
    {
        throw "CIDR not found & Subnet resource not found & AccessRestrictionRuleName not found. Something went horribly wrong."
    }
}

function Confirm-ParametersForWhitelist
{
    [CmdletBinding()]
    param (
        [Parameter()][string] $CIDR,
        [Parameter()][string] $AccessRestrictionRuleName,
        [Parameter()][string] $SubnetName,
        [Parameter()][string] $VnetName,
        [Parameter()][string] $VnetResourceGroupName
    )

    if ($CIDR -and $SubnetName -and $VnetName -and $VnetResourceGroupName)
    {
        throw "You can not enter a CIDRToWhitelist (CIDR whitelisting) in combination with SubnetName, VnetName, VnetResourceGroupName (Subnet whitelisting). Choose one of the two options."
    }

    # Make sure it's either filled or all empty
    if (!(($SubnetName -and $VnetName -and $VnetResourceGroupname) -or (!$SubnetName -and !$VnetName -and !$VnetResourceGroupname)))
    {
        throw "Either fill SubnetName, VnetName & VnetResourceGroupName or leave them all blank."
    } 
}

function New-CIDR
{
    [CmdletBinding()]
    param (
        [Parameter()][string] $CIDR,
        [Parameter()][string] $CIDRSuffix,
        [Parameter()][string] $SubnetName,
        [Parameter()][string] $VnetName,
        [Parameter()][string] $VnetResourceGroupName
    )

    # Autogenerate CIDR if no CIDR or Subnet is passed
    if (!$CIDR -and (!$SubnetName -or !$VnetName -or !$VnetResourceGroupName))
    {
        $response = Invoke-WebRequest 'https://ipinfo.io/ip'
        return $response.Content.Trim() + $CIDRSuffix
    }

    return $CIDR
}

function New-AccessRestrictionRuleName
{
    # todo: naamgeving CharacterToReplaceWith
    [CmdletBinding()]
    param (
        [Parameter()][string] $AccessRestrictionRuleName,
        [Parameter()][string] $CIDR,
        [Parameter()][string] $SubnetName,
        [Parameter()][string] $VnetName,
        [Parameter()][string] $VnetResourceGroupName,
        [Parameter()][string] $CharacterToReplaceWith
    )

    if ($CharacterToReplaceWith -eq '')
    {
        $CharacterToReplaceWith = '-'
    }

    # Autogenerate name if no name is given
    if (!$AccessRestrictionRuleName -and $CIDR)
    {
        $AccessRestrictionRuleName = ($CIDR -replace "\.", $CharacterToReplaceWith) -replace "/", $CharacterToReplaceWith
    }
    elseif (!$AccessRestrictionRuleName -and $SubnetName -and $VnetName -and $VnetResourceGroupName)
    {
        $AccessRestrictionRuleName = ToMd5Hash -InputString "$($VnetResourceGroupName)_$($VnetName)_$($SubnetName)_allow"
    }

    return $AccessRestrictionRuleName
}

#endregion